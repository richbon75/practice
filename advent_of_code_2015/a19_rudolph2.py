"""
This problem took me awhile to solve. Here's my general approach:

1. Create a list of reversion pattern tuples in the format
   of (current_pattern, reverted_pattern) ex: ('TiRnFAr', 'B')
2. Create a generator that's able to generate ALL possible single-step
   reversions of a given molecule.
3. For relatively short molecules, create a function that can find the shortest
   possible reversion we can make from it, and the fewest steps to get there.
   It reduces the search space by using memoization. But still won't work
   for very long molecules, because the possible search space is still too large.
4. Realize that we can break up the very long molecule into much shorter ones
   based on the boundaries created by the 'Ar' symbols, which only appear on the
   right-most side of the patterns - so we can never find a pattern that will
   match "across" an 'Ar' symbol.
5. Split up the large molecule into smaller molecules, and process them with
   our "short molecule solver" function -- appending the remaining minimal
   molecule from each section onto the beginning of the next section before
   solving it, and keep a running total of the steps required to get there.
"""

# "reversions" will be a list of tuples, where each tuple is a rule in the format:
#   (current_pattern, reverted_pattern)
reversions = list()

# medicine will hold the big long string that is Rudolph's medicine
medicine = None

# Import problem specifics from file
f = open('a19_input.txt', 'r')
for line in f:
    line = line.strip()
    if '=>' in line:
        parts = line.split()
        reversions.append((parts[2], parts[0]))
    elif line:
        medicine = line

def find_reversions(string, reversions):
    """Given a string, generate all possible single-step reversions."""
    for reversion in reversions:
        start = string.find(reversion[0], 0)
        while start >= 0:
            # print('replacing {} with {} in {} at loc {}'.format(
            #    reversion[0], reversion[1], string, start))
            yield string[0:start] + reversion[1] + string[start+len(reversion[0]):]
            start = string.find(reversion[0], start+1)

def find_minimal_reversion(string, reversions, memo=None):
    """Finds a minimal reversion for a given input string.
    Returns a tuple:  (minimal reversion, number of steps)
    Note: We can't run this on a very large input string, since
    the search space is too huge - we'll run too long, achieve stack overflow,
    or use up too much memory with the memo cache. We need to run
    this on smaller bite-sized chunks, which is how this gets
    used by the long_molecule_reversion() function."""
    if memo is None:
        memo = dict()
    if string in memo:      # memoize to prune search tree
       return memo[string]
    local_best = None
    possible_replacements = 0
    # for every possible replacement:
    for next_step in find_reversions(string, reversions):
        # find_minimal_reversion for the resulting string
        possible_replacements += 1
        result = find_minimal_reversion(next_step, reversions, memo)
        if local_best is None:
            local_best = result
        # What's a better minimal reversion?
        elif (# if we found 'e'
              (result[0] == 'e' and local_best[0] != 'e') or 
              # or if we found a shorter molecule
              (len(local_best[0]) > len(result[0])) or 
              # or if we found a shorter path to the same molecule
              (local_best[0] == result[0] and local_best[1] > result[1])):
            local_best = result
    # report best version (incrementing number of steps if generated by recursion)
    if possible_replacements == 0: # base case - we're already at a local minimum
        local_best = (string, 0)
    else:
        local_best = (local_best[0], local_best[1] + 1)
    memo[string] = local_best
    return local_best

def long_molecule_reversion(string, reversions):
    """We can take the long molecule apart into shorter sections by splitting
    on the 'Ar' symbol. Since all reversion patterns only have 'Ar' on the
    right side, we can't match a pattern "across" any existing 'Ar'."""
    # chop up the long molecule into sections bounded by 'Ar'
    sections = string.split('Ar')
    # for all except the last section, reattach the 'Ar' to the end
    for i in range(len(sections)-1):
        sections[i] += 'Ar'
    # go through each section and find its minimal reversion
    #  append the remaining molecule portion from the prior section
    #  as a prefix to the next section before solving
    prefix = ''
    total_replacements = 0
    for s in sections:
        # print('reverting {} + {}'.format(prefix, s))
        result = find_minimal_reversion(prefix + s, reversions)
        # print('result = {}'.format(result))
        prefix = result[0]
        total_replacements += result[1]
        # print('total_replacements so far = {}'.format(total_replacements))
    return (prefix, total_replacements)

# LET'S DO THIS.
result = long_molecule_reversion(medicine, reversions)
print('Final result:')
print("The medicine can be created from '{}' in a minimum of {} steps."
      .format(result[0], result[1]))


